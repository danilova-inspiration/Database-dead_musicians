Простые запросы:
1)Выбрать 3 самых молодых музыкантов и вывести их причину смерти

SELECT name_surname, age(data_death,birthday), cause_death FROM musicians ORDER BY age LIMIT 3;

До оптимизации:

  QUERY PLAN
-------------------------------------------------------------------------------------------------------------------
 Limit  (cost=1.49..1.49 rows=3 width=528) (actual time=0.222..0.225 rows=3 loops=1)
   ->  Sort  (cost=1.49..1.53 rows=16 width=528) (actual time=0.220..0.222 rows=3 loops=1)
         Sort Key: (age((data_death)::timestamp with time zone, (birthday)::timestamp with time zone))
         Sort Method: top-N heapsort  Memory: 25kB
         ->  Seq Scan on musicians  (cost=0.00..1.28 rows=16 width=528) (actual time=0.072..0.152 rows=16 loops=1)
 Planning time: 0.741 ms
 Execution time: 0.343 ms
(7 строк)

Оптимизация: добавлен индекс по id страны и имении фамилии
CREATE INDEX ON musicians(name_surname);
CREATE INDEX ON musicians(id_country);
EXPLAIN(ANALYZE) SELECT name_surname, age(data_death,birthday), cause_death FROM musicians ORDER BY age LIMIT 3;

После оптимизации:

                                                     QUERY PLAN
-------------------------------------------------------------------------------------------------------------------
 Limit  (cost=1.49..1.49 rows=3 width=528) (actual time=0.123..0.124 rows=3 loops=1)
   ->  Sort  (cost=1.49..1.53 rows=16 width=528) (actual time=0.121..0.122 rows=3 loops=1)
         Sort Key: (age((data_death)::timestamp with time zone, (birthday)::timestamp with time zone))
         Sort Method: top-N heapsort  Memory: 25kB
         ->  Seq Scan on musicians  (cost=0.00..1.28 rows=16 width=528) (actual time=0.039..0.086 rows=16 loops=1)
 Planning time: 1.291 ms
 Execution time: 0.170 ms
(7 строк)

2)Выбрать всех музыкантов, не имеющих музыкальное образование и скончавшихся в 21 веке

SELECT name_surname, cause_death FROM musicians WHERE (data_death > '2000-01-01'AND musicians.music_education='No'); 

До оптимизации:

 QUERY PLAN
-----------------------------------------------------------------------------------------------------
 Seq Scan on musicians  (cost=0.00..1.20 rows=3 width=512) (actual time=0.058..0.066 rows=8 loops=1)
   Filter: ((NOT music_education) AND (data_death > '2000-01-01'::date))
   Rows Removed by Filter: 8
 Planning time: 0.290 ms
 Execution time: 0.112 ms
(5 строк)

Оптимизация: добавлен индекс по имени фамилии музыканта
CREATE INDEX ON musicians(name_surname);
EXPLAIN(ANALYZE) SELECT name_surname, cause_death FROM musicians WHERE (data_death > '2000-01-01'AND musicians.music_education='No');

После оптимизации:

  QUERY PLAN
-----------------------------------------------------------------------------------------------------
 Seq Scan on musicians  (cost=0.00..1.20 rows=3 width=512) (actual time=0.035..0.043 rows=8 loops=1)
   Filter: ((NOT music_education) AND (data_death > '2000-01-01'::date))
   Rows Removed by Filter: 8
 Planning time: 1.371 ms
 Execution time: 0.088 ms
(5 строк)

3)Выбрать все награды в названии которых присутствует слово "Awards" и которые были учреждены после 1962 года

SELECT name,begin FROM Music_rewards WHERE name LIKE '%Awards%' AND Music_rewards.begin>1962;

До оптимизации:

QUERY PLAN
----------------------------------------------------------------------------------------------------------
 Seq Scan on music_rewards  (cost=0.00..16.15 rows=1 width=160) (actual time=0.061..0.080 rows=8 loops=1)
   Filter: (((name)::text ~~ '%Awards%'::text) AND (begin > 1962))
   Rows Removed by Filter: 7
 Planning time: 0.268 ms
 Execution time: 0.131 ms
(5 строк)

Оптимизация: добавлен индекс по имени награды
CREATE INDEX ON Music_rewards(name);
EXPLAIN(ANALYZE)SELECT name,begin FROM Music_rewards WHERE name LIKE '%Awards%' AND Music_rewards.begin>1962;

После оптимизации:

QUERY PLAN
---------------------------------------------------------------------------------------------------------
 Seq Scan on music_rewards  (cost=0.00..1.23 rows=1 width=160) (actual time=0.036..0.047 rows=8 loops=1)
   Filter: (((name)::text ~~ '%Awards%'::text) AND (begin > 1962))
   Rows Removed by Filter: 7
 Planning time: 1.200 ms
 Execution time: 0.088 ms
(5 строк)

4)Вывести 3 самых старых музыкантов, у которых в причине смерти содержится слово ‘cancer’ и которые родились после 1900 года.

SELECT name_surname, cause_death, age(data_death,birthday) FROM musicians WHERE (cause_death LIKE '%cancer%' AND musicians.birthday > '1900-01-01' ) ORDER BY age DESC LIMIT 3;

До оптимизации:

 QUERY PLAN
-----------------------------------------------------------------------------------------------------------------
 Limit  (cost=1.26..1.26 rows=1 width=528) (actual time=0.192..0.194 rows=3 loops=1)
   ->  Sort  (cost=1.26..1.26 rows=1 width=528) (actual time=0.191..0.192 rows=3 loops=1)
         Sort Key: (age((data_death)::timestamp with time zone, (birthday)::timestamp with time zone)) DESC
         Sort Method: quicksort  Memory: 25kB
         ->  Seq Scan on musicians  (cost=0.00..1.25 rows=1 width=528) (actual time=0.083..0.101 rows=4 loops=1)
               Filter: (((cause_death)::text ~~ '%cancer%'::text) AND (birthday > '1900-01-01'::date))
               Rows Removed by Filter: 12
 Planning time: 6.017 ms
 Execution time: 0.260 ms
(9 строк)

Оптимизация: добавлен индекс по имени фамилии
CREATE INDEX ON musicians(name_surname);
EXPLAIN(ANALYZE)SELECT name_surname, cause_death, age(data_death,birthday) FROM musicians WHERE (cause_death LIKE '%cancer%' AND musicians.birthday > '1900-01-01' ) ORDER BY age DESC LIMIT 3;

После оптимизации:

  QUERY PLAN
-----------------------------------------------------------------------------------------------------------------
 Limit  (cost=1.26..1.26 rows=1 width=528) (actual time=0.103..0.104 rows=3 loops=1)
   ->  Sort  (cost=1.26..1.26 rows=1 width=528) (actual time=0.101..0.102 rows=3 loops=1)
         Sort Key: (age((data_death)::timestamp with time zone, (birthday)::timestamp with time zone)) DESC
         Sort Method: quicksort  Memory: 25kB
         ->  Seq Scan on musicians  (cost=0.00..1.25 rows=1 width=528) (actual time=0.057..0.075 rows=4 loops=1)
               Filter: (((cause_death)::text ~~ '%cancer%'::text) AND (birthday > '1900-01-01'::date))
               Rows Removed by Filter: 12
 Planning time: 1.441 ms
 Execution time: 0.164 ms
(9 строк)


5)Вывести значение среднего возраста музыкантов, которые скончались от сердечной недостаточности

SELECT AVG(age(data_death,birthday)) FROM musicians WHERE (musicians.cause_death LIKE '%Heart failure%');

До оптимизации:

  QUERY PLAN
---------------------------------------------------------------------------------------------------------
 Aggregate  (cost=1.21..1.22 rows=1 width=16) (actual time=0.130..0.130 rows=1 loops=1)
   ->  Seq Scan on musicians  (cost=0.00..1.20 rows=1 width=8) (actual time=0.057..0.074 rows=3 loops=1)
         Filter: ((cause_death)::text ~~ '%Heart failure%'::text)
         Rows Removed by Filter: 13
 Planning time: 0.533 ms
 Execution time: 0.260 ms
(6 строк)

Оптимизация: добавлен индекс по причине смерти
CREATE INDEX ON musicians(cause_death);
EXPLAIN(ANALYZE)SELECT AVG(age(data_death,birthday)) FROM musicians WHERE (musicians.cause_death LIKE '%Heart failure%');

После оптимизации:

 QUERY PLAN
---------------------------------------------------------------------------------------------------------
 Aggregate  (cost=1.21..1.22 rows=1 width=16) (actual time=0.116..0.116 rows=1 loops=1)
   ->  Seq Scan on musicians  (cost=0.00..1.20 rows=1 width=8) (actual time=0.056..0.068 rows=3 loops=1)
         Filter: ((cause_death)::text ~~ '%Heart failure%'::text)
         Rows Removed by Filter: 13
 Planning time: 1.368 ms
 Execution time: 0.222 ms
(6 строк)

Средние запросы:
1)Выбрать всех музыкантов из Великобритании и сортировать их от страшего к младшему.

SELECT name_surname, country, age(data_death,birthday) FROM (musicians AS m INNER JOIN countries AS c ON (m.id_country = c.id)) WHERE (c.country = 'Great Britain') ORDER BY age DESC;

До оптимизации:

QUERY PLAN
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=20.13..20.14 rows=1 width=328) (actual time=1.018..1.019 rows=6 loops=1)
   Sort Key: (age((musicians.data_death)::timestamp with time zone, (musicians.birthday)::timestamp with time zone)) DESC
   Sort Method: quicksort  Memory: 25kB
   ->  Hash Join  (cost=8.18..20.12 rows=1 width=328) (actual time=0.861..0.900 rows=6 loops=1)
         Hash Cond: (musicians.id_country = countries.id)
         ->  Seq Scan on musicians  (cost=0.00..11.40 rows=140 width=168) (actual time=0.036..0.044 rows=16 loops=1)
         ->  Hash  (cost=8.17..8.17 rows=1 width=160) (actual time=0.060..0.060 rows=1 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  Index Scan using countries_country_key on countries  (cost=0.15..8.17 rows=1 width=160) (actual time=0.050..0.051 rows=1 loops=1)
                     Index Cond: ((country)::text = 'Great Britain'::text)
 Planning time: 0.431 ms
 Execution time: 1.117 ms
(12 строк)

Оптимизация: добавлен индекс по id страны

CREATE INDEX ON musicians(id_country);
EXPLAIN (ANALYZE) SELECT name_surname, country, age(data_death,birthday) FROM (musicians CROSS JOIN countries) WHERE (musicians.id_country = countries.id AND countries.country = 'Great Britain') ORDER BY age DESC;

После оптимизации:

QUERY PLAN
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=9.43..9.43 rows=1 width=328) (actual time=0.189..0.191 rows=6 loops=1)
   Sort Key: (age((musicians.data_death)::timestamp with time zone, (musicians.birthday)::timestamp with time zone)) DESC
   Sort Method: quicksort  Memory: 25kB
   ->  Hash Join  (cost=8.18..9.42 rows=1 width=328) (actual time=0.135..0.163 rows=6 loops=1)
         Hash Cond: (musicians.id_country = countries.id)
         ->  Seq Scan on musicians  (cost=0.00..1.16 rows=16 width=168) (actual time=0.030..0.034 rows=16 loops=1)
         ->  Hash  (cost=8.17..8.17 rows=1 width=160) (actual time=0.051..0.051 rows=1 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  Index Scan using countries_country_key on countries  (cost=0.15..8.17 rows=1 width=160) (actual time=0.030..0.031 rows=1 loops=1)
                     Index Cond: ((country)::text = 'Great Britain'::text)
 Planning time: 1.972 ms
 Execution time: 0.275 ms
(12 строк)

2)Выбрать музыкантов, которые получили британскую премию, учрежденную после 1955 года

SELECT name_surname, name, begin FROM (countries AS c INNER JOIN (music_rewards AS mr INNER JOIN (musicians_music_rewards_relation AS mmrr INNER JOIN musicians AS m ON (mmrr.id_musician = m.id)) ON (mmrr. id_music_reward = mr.id)) ON (mr.country_m=c.id)) WHERE (c.country = 'Great Britain' AND mr.begin>'1955');

До оптимизации:

 QUERY PLAN
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=23.97..62.78 rows=5 width=316) (actual time=0.206..0.239 rows=6 loops=1)
   ->  Hash Join  (cost=23.84..61.94 rows=5 width=164) (actual time=0.192..0.204 rows=6 loops=1)
         Hash Cond: (mmrr.id_music_reward = mr.id)
         ->  Seq Scan on musicians_music_rewards_relation mmrr  (cost=0.00..30.40 rows=2040 width=8) (actual time=0.034..0.038 rows=24 loops=1)
         ->  Hash  (cost=23.83..23.83 rows=1 width=164) (actual time=0.130..0.130 rows=5 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  Hash Join  (cost=8.18..23.83 rows=1 width=164) (actual time=0.101..0.118 rows=5 loops=1)
                     Hash Cond: (mr.country_m = c.id)
                     ->  Seq Scan on music_rewards mr  (cost=0.00..15.13 rows=137 width=168) (actual time=0.022..0.033 rows=14 loops=1)
                           Filter: (begin > 1955)
                           Rows Removed by Filter: 1
                     ->  Hash  (cost=8.17..8.17 rows=1 width=4) (actual time=0.045..0.045 rows=1 loops=1)
                           Buckets: 1024  Batches: 1  Memory Usage: 9kB
                           ->  Index Scan using countries_country_key on countries c  (cost=0.15..8.17 rows=1 width=4) (actual time=0.028..0.031 rows=1 loops=1)
                                 Index Cond: ((country)::text = 'Great Britain'::text)
   ->  Index Scan using musicians_pk on musicians m  (cost=0.14..0.16 rows=1 width=160) (actual time=0.004..0.004 rows=1 loops=6)
         Index Cond: (id = mmrr.id_musician)
 Planning time: 0.987 ms
 Execution time: 0.484 ms
(19 строк)

Оптимизация: добавлен индекс по имени фамилии музыканта

CREATE INDEX ON musicians(name_surname);
EXPLAIN (ANALYZE) SELECT name_surname, name, begin FROM (countries AS c INNER JOIN (music_rewards AS mr INNER JOIN (musicians_music_rewards_relation AS mmrr INNER JOIN musicians AS m ON (mmrr.id_musician = m.id)) ON (mmrr. id_music_reward = mr.id)) ON (mr.country_m=c.id)) WHERE (c.country = 'Great Britain' AND mr.begin>'1955');

После оптимизации: 

                                                                           QUERY PLAN
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=23.97..62.78 rows=5 width=316) (actual time=0.186..0.219 rows=6 loops=1)
   ->  Hash Join  (cost=23.84..61.94 rows=5 width=164) (actual time=0.174..0.187 rows=6 loops=1)
         Hash Cond: (mmrr.id_music_reward = mr.id)
         ->  Seq Scan on musicians_music_rewards_relation mmrr  (cost=0.00..30.40 rows=2040 width=8) (actual time=0.030..0.033 rows=24 loops=1)
         ->  Hash  (cost=23.83..23.83 rows=1 width=164) (actual time=0.118..0.118 rows=5 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  Hash Join  (cost=8.18..23.83 rows=1 width=164) (actual time=0.098..0.109 rows=5 loops=1)
                     Hash Cond: (mr.country_m = c.id)
                     ->  Seq Scan on music_rewards mr  (cost=0.00..15.13 rows=137 width=168) (actual time=0.019..0.027 rows=14 loops=1)
                           Filter: (begin > 1955)
                           Rows Removed by Filter: 1
                     ->  Hash  (cost=8.17..8.17 rows=1 width=4) (actual time=0.042..0.042 rows=1 loops=1)
                           Buckets: 1024  Batches: 1  Memory Usage: 9kB
                           ->  Index Scan using countries_country_key on countries c  (cost=0.15..8.17 rows=1 width=4) (actual time=0.033..0.034 rows=1 loops=1)
                                 Index Cond: ((country)::text = 'Great Britain'::text)
   ->  Index Scan using musicians_pk on musicians m  (cost=0.14..0.16 rows=1 width=160) (actual time=0.003..0.004 rows=1 loops=6)
         Index Cond: (id = mmrr.id_musician)
 Planning time: 1.926 ms
 Execution time: 0.359 ms
(19 строк)

3)Выбрать вокалистов из Америки, которые скончались после 1990 года, вывести причину и дату их смерти

SELECT name_surname, cause_death, data_death FROM (countries AS c INNER JOIN (musical_instruments AS mi INNER JOIN (musicians AS m INNER JOIN musicians_musical_instruments_relation AS mmir ON (mmir.id_musician=m.id)) ON (mmir. id_instrument = mi.id)) ON (m.id_country = c.id)) WHERE (c.country = 'USA' AND mi.instrument = 'vocal' AND m.data_death>='1990-01-01');

До оптимизации:

    QUERY PLAN
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=9.59..14.45 rows=1 width=516) (actual time=0.369..0.427 rows=2 loops=1)
   ->  Hash Join  (cost=9.44..11.20 rows=3 width=520) (actual time=0.335..0.367 rows=6 loops=1)
         Hash Cond: (mmir.id_musician = m.id)
         ->  Seq Scan on musicians_musical_instruments_relation mmir  (cost=0.00..1.53 rows=53 width=8) (actual time=0.080..0.091 rows=53 loops=1)
         ->  Hash  (cost=9.43..9.43 rows=1 width=520) (actual time=0.218..0.218 rows=3 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  Nested Loop  (cost=0.15..9.43 rows=1 width=520) (actual time=0.149..0.174 rows=3 loops=1)
                     Join Filter: (c.id = m.id_country)
                     Rows Removed by Join Filter: 8
                     ->  Index Scan using countries_country_key on countries c  (cost=0.15..8.17 rows=1 width=4) (actual time=0.089..0.092 rows=1 loops=1)
                           Index Cond: ((country)::text = 'USA'::text)
                     ->  Seq Scan on musicians m  (cost=0.00..1.20 rows=5 width=524) (actual time=0.053..0.063 rows=11 loops=1)
                           Filter: (data_death >= '1990-01-01'::date)
                           Rows Removed by Filter: 5
   ->  Index Scan using musical_instruments_pk on musical_instruments mi  (cost=0.15..1.07 rows=1 width=4) (actual time=0.008..0.008 rows=0 loops=6)
         Index Cond: (id = mmir.id_instrument)
         Filter: ((instrument)::text = 'vocal'::text)
         Rows Removed by Filter: 1
 Planning time: 2.046 ms
 Execution time: 0.673 ms
(20 строк)

Оптимизация:добавлен индекс по имени фамилии музыканта

CREATE INDEX ON musicians(name_surname);
EXPLAIN (ANALYZE) SELECT name_surname, cause_death, data_death FROM (countries AS c INNER JOIN (musical_instruments AS mi INNER JOIN (musicians AS m INNER JOIN musicians_musical_instruments_relation AS mmir ON (mmir.id_musician=m.id)) ON (mmir. id_instrument = mi.id)) ON (m.id_country = c.id)) WHERE (c.country = 'USA' AND mi.instrument = 'vocal' AND m.data_death>='1990-01-01');

После оптимизации:

                                                                        QUERY PLAN
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=9.59..14.45 rows=1 width=516) (actual time=0.153..0.201 rows=2 loops=1)
   ->  Hash Join  (cost=9.44..11.20 rows=3 width=520) (actual time=0.141..0.168 rows=6 loops=1)
         Hash Cond: (mmir.id_musician = m.id)
         ->  Seq Scan on musicians_musical_instruments_relation mmir  (cost=0.00..1.53 rows=53 width=8) (actual time=0.031..0.037 rows=53 loops=1)
         ->  Hash  (cost=9.43..9.43 rows=1 width=520) (actual time=0.083..0.083 rows=3 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  Nested Loop  (cost=0.15..9.43 rows=1 width=520) (actual time=0.049..0.062 rows=3 loops=1)
                     Join Filter: (c.id = m.id_country)
                     Rows Removed by Join Filter: 8
                     ->  Index Scan using countries_country_key on countries c  (cost=0.15..8.17 rows=1 width=4) (actual time=0.023..0.024 rows=1 loops=1)
                           Index Cond: ((country)::text = 'USA'::text)
                     ->  Seq Scan on musicians m  (cost=0.00..1.20 rows=5 width=524) (actual time=0.021..0.030 rows=11 loops=1)
                           Filter: (data_death >= '1990-01-01'::date)
                           Rows Removed by Filter: 5
   ->  Index Scan using musical_instruments_pk on musical_instruments mi  (cost=0.15..1.07 rows=1 width=4) (actual time=0.004..0.004 rows=0 loops=6)
         Index Cond: (id = mmir.id_instrument)
         Filter: ((instrument)::text = 'vocal'::text)
         Rows Removed by Filter: 1
 Planning time: 2.140 ms
 Execution time: 0.332 ms
(20 строк)

Сложные запросы:
1)Вывести всех участников музыкальной группы самого многочисленного жанра, которая была основана раньше других групп из этого жанра

SELECT name_surname, name_group FROM (musicians INNER JOIN (music_groups INNER JOIN musicians_music_groups_relation ON (musicians_music_groups_relation.id_music_group=music_groups.id)) ON (musicians_music_groups_relation.id_musician=musicians.id)) WHERE name_group=( SELECT N.name_group FROM (SELECT genres.genre, name_group, data_begin FROM (music_groups INNER JOIN genres ON (music_groups.genre=genres.id))) AS N WHERE genre=(SELECT g.genre FROM genres AS g LEFT JOIN music_groups AS m ON (g.id=m.genre) GROUP BY g.id ORDER BY count(g.id) DESC LIMIT 1) ORDER BY data_begin LIMIT 1);

2)Посчитать количество музыкантов, которые умели играть на гитаре и скончались после 1990 года

WITH t1 AS (SELECT instrument, name_surname FROM (musical_instruments AS mi INNER JOIN(musicians_musical_instruments_relation AS mmir INNER JOIN musicians AS m ON (mmir.id_musician=m.id)) ON (mmir.id_instrument=mi.id AND mi.instrument=’guitar’))), t2 AS (SELECT name_surname FROM (countries INNER JOIN (musical_instruments INNER JOIN (musicians INNER JOIN musicians_musical_instruments_relation ON (musicians_musical_instruments_relation.id_musician=musicians.id)) ON (musicians_musical_instruments_relation. id_instrument = musical_instruments.id)) ON (musicians.id_country = countries.id)) WHERE (countries.country = 'Great Britain' AND musical_instruments.instrument = 'guitar') GROUP BY (name_surname, data_death) HAVING musicians.data_death>='1990-01-01') SELECT count(instrument) FROM t1 WHERE name_surname in (SELECT name_surname FROM t2); 

3)Вывести музыкантов, получивших американские награды, и игравших в жанрах, в которых присутствует слово «Rock», вывести полные названия этих жанров.

WITH r1 AS(SELECT name_surname, g.genre FROM(musicians AS m INNER JOIN(musicians_music_groups_relation AS mmgr INNER JOIN(music_groups AS mg INNER JOIN genres AS g ON (mg.genre=g.id AND g.genre LIKE '%Rock%' )) ON (mmgr.id_music_group=mg.id)) ON (mmgr.id_musician=m.id)) ORDER BY name_surname), r2 AS(SELECT name_surname, name, begin FROM (musicians_music_rewards_relation CROSS JOIN musicians CROSS JOIN music_rewards CROSS JOIN countries) WHERE (musicians_music_rewards_relation. id_music_reward = music_rewards.id AND musicians_music_rewards_relation.id_musician = musicians.id AND music_rewards.country_m=countries.id AND countries.country = 'USA')) SELECT name_surname,genre FROM r1 WHERE name_surname in (SELECT name_surname FROM r2);


